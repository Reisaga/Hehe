local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local task_wait = task.wait
local util_xpcall = xpcall

local PrivateServerManager = {}
PrivateServerManager.__index = PrivateServerManager

local function silentTrace(err) end

local function safeInvoke(fn, ...)
	local ok, res = util_xpcall(function() return fn(...) end, silentTrace)
	if ok then
		return true, res
	end
	return false, nil
end

local function clamp(n, a, b)
	if n < a then return a end
	if n > b then return b end
	return n
end

function PrivateServerManager.new(placeId, opts)
	local o = opts or {}
	local self = setmetatable({}, PrivateServerManager)
	self.placeId = placeId or game.PlaceId
	self.maxAttempts = clamp(tonumber(o.maxAttempts) or 3, 1, 50)
	self.baseBackoff = tonumber(o.baseBackoff) or 0.5
	self.exponential = o.exponential ~= false
	self.autoRetry = o.autoRetry == true
	self.reserveTimeout = tonumber(o.reserveTimeout) or 8
	self._cache = setmetatable({}, { __mode = "k" })
	self._running = false
	return self
end

function PrivateServerManager:_isAsyncAllowed()
	local ok, allowed = safeInvoke(function()
		return TeleportService.IsAsyncTeleportAllowedToPlaceId and TeleportService:IsAsyncTeleportAllowedToPlaceId(self.placeId)
	end)
	if ok and allowed == true then
		return true
	end
	return false
end

function PrivateServerManager:_reserveServerOnce()
	local ok, code = safeInvoke(function()
		return TeleportService.ReserveServer and TeleportService:ReserveServer(self.placeId)
	end)
	if ok and type(code) == "string" and #code > 0 then
		return true, code
	end
	return false, nil
end

function PrivateServerManager:_reserveServerAttempts()
	local attempt = 0
	local lastCode = nil
	while attempt < self.maxAttempts do
		attempt = attempt + 1
		local got, code = self:_reserveServerOnce()
		if got then
			lastCode = code
			break
		end
		local backoff = self.baseBackoff * (self.exponential and (2 ^ (attempt - 1)) or attempt)
		task_wait(backoff)
	end
	return lastCode
end

function PrivateServerManager:_teleportWithCode(player, code)
	local ok = false
	if type(code) == "string" and #code > 0 and player and player:IsA and player:IsA("Player") then
		local invoked, _ = safeInvoke(function()
			TeleportService:TeleportToPrivateServer(self.placeId, code, { player })
		end)
		if invoked then ok = true end
	end
	return ok
end

function PrivateServerManager:CreateAndTeleport(player)
	local resultStatus = false
	local resultCode = nil
	local errTag = "invalid_player"
	if player and player.IsA and player:IsA(player, "Player") then
		errTag = "not_allowed"
		local allowed = self:_isAsyncAllowed()
		if allowed then
			errTag = "reserve_failed"
			local code = self:_reserveServerAttempts()
			if type(code) == "string" and #code > 0 then
				errTag = "teleport_failed"
				local tpOk = self:_teleportWithCode(player, code)
				if tpOk then
					resultStatus = true
					resultCode = code
					errTag = nil
				else
					if self.autoRetry then
						local tries = 0
						while tries < self.maxAttempts and resultStatus == false do
							tries = tries + 1
							task_wait(self.baseBackoff * tries)
							local newCode = self:_reserveServerAttempts()
							if type(newCode) == "string" and #newCode > 0 then
								if self:_teleportWithCode(player, newCode) then
									resultStatus = true
									resultCode = newCode
									errTag = nil
									break
								end
							end
						end
					end
				end
			end
		end
	end
	return resultStatus, resultCode, errTag
end

setmetatable(PrivateServerManager, {
	__call = function(_, ...)
		return PrivateServerManager.new(...)
	end,
	__metatable = false
})

local manager = PrivateServerManager(game.PlaceId, { maxAttempts = 4, baseBackoff = 0.6, autoRetry = true })
task.spawn(function()
	local plr = Players.LocalPlayer
	if plr then
		manager:CreateAndTeleport(plr)
	end
end)
