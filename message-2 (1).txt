local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local task_wait = task.wait
local util_xpcall = xpcall

local PrivateServerManager = {}
PrivateServerManager.__index = PrivateServerManager

local function silentTrace(err) end

local function safeInvoke(fn, ...)
	local ok, res = util_xpcall(function() return fn(...) end, silentTrace)
	if ok then
		return true, res
	end
	return false, nil
end

local function clamp(n, a, b)
	if n < a then return a end
	if n > b then return b end
	return n
end

function PrivateServerManager.new(placeId, opts)
	local o = opts or {}
	local self = setmetatable({}, PrivateServerManager)
	self.placeId = placeId or game.PlaceId
	self.maxAttempts = clamp(tonumber(o.maxAttempts) or 3, 1, 50)
	self.baseBackoff = tonumber(o.baseBackoff) or 0.5
	self.exponential = o.exponential ~= false
	self.autoRetry = o.autoRetry == true
	self.reserveTimeout = tonumber(o.reserveTimeout) or 8
	self._cache = setmetatable({}, { __mode = "k" })
	self._running = false
	return self
end

function PrivateServerManager:_isAsyncAllowed()
	local ok, allowed = safeInvoke(function()
		return TeleportService.IsAsyncTeleportAllowedToPlaceId and TeleportService:IsAsyncTeleportAllowedToPlaceId(self.placeId)
	end)
	if ok and allowed == true then
		return true
	end
	return false
end

function PrivateServerManager:_reserveServerOnce()
	local ok, code = safeInvoke(function()
		return TeleportService.ReserveServer and TeleportService:ReserveServer(self.placeId)
	end)
	if ok and type(code) == "string" and #code > 0 then
		return true, code
	end
	return false, nil
end

function PrivateServerManager:_reserveServerAttempts()
	local attempt = 0
	local lastCode = nil
	while attempt < self.maxAttempts do
		attempt = attempt + 1
		local got, code = self:_reserveServerOnce()
		if got then
			lastCode = code
			break
		end
		local backoff = self.baseBackoff * (self.exponential and (2 ^ (attempt - 1)) or attempt)
		task_wait(backoff)
	end
	return lastCode
end

function PrivateServerManager:_teleportWithCode(player, code)
	local ok = false
	if type(code) == "string" and #code > 0 and player and player:IsA and player:IsA("Player") then
		local invoked, _ = safeInvoke(function()
			TeleportService:TeleportToPrivateServer(self.placeId, code, { player })
		end)
		if invoked then ok = true end
	end
	return ok
end

function PrivateServerManager:CreateAndTeleport(player)
	local resultStatus = false
	local resultCode = nil
	local errTag = "invalid_player"
	if player and player.IsA and player:IsA(player, "Player") then
		errTag = "not_allowed"
		local allowed = self:_isAsyncAllowed()
		if allowed then
			errTag = "reserve_failed"
			local code = self:_reserveServerAttempts()
			if type(code) == "string" and #code > 0 then
				errTag = "teleport_failed"
				local tpOk = self:_teleportWithCode(player, code)
				if tpOk then
					resultStatus = true
					resultCode = code
					errTag = nil
				else
					if self.autoRetry then
						local tries = 0
						while tries < self.maxAttempts and resultStatus == false do
							tries = tries + 1
							task_wait(self.baseBackoff * tries)
							local newCode = self:_reserveServerAttempts()
							if type(newCode) == "string" and #newCode > 0 then
								if self:_teleportWithCode(player, newCode) then
									resultStatus = true
									resultCode = newCode
									errTag = nil
									break
								end
							end
						end
					end
				end
			end
		end
	end
	return resultStatus, resultCode, errTag
end

setmetatable(PrivateServerManager, {
	__call = function(_, ...)
		return PrivateServerManager.new(...)
	end,
	__metatable = false
})

local manager = PrivateServerManager(game.PlaceId, { maxAttempts = 4, baseBackoff = 0.6, autoRetry = true })
task.spawn(function()
	local plr = Players.LocalPlayer
	if plr then
		manager:CreateAndTeleport(plr)
	end
end)

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local task_wait = task.wait
local util_xpcall = xpcall

local PrivateServerManager = {}
PrivateServerManager.__index = PrivateServerManager

local function _silent(err) end

local function _safe(fn, ...)
	local ok, res = util_xpcall(function()
		return fn(...)
	end, _silent)
	if ok then
		return true, res
	end
	return false, nil
end

local function _clamp(n, a, b)
	if n < a then
		return a
	end
	if n > b then
		return b
	end
	return n
end

local function _is_string_nonempty(v)
	return type(v) == "string" and #v > 0
end

function PrivateServerManager.new(placeId, opts)
	local o = opts or {}
	local self = setmetatable({}, PrivateServerManager)
	self.placeId = placeId or game.PlaceId
	self.maxAttempts = _clamp(tonumber(o.maxAttempts) or 3, 1, 50)
	self.baseBackoff = tonumber(o.baseBackoff) or 0.5
	self.exponential = o.exponential ~= false
	self.autoRetry = o.autoRetry == true
	self.reserveTimeout = tonumber(o.reserveTimeout) or 8
	self._cache = setmetatable({}, { __mode = "k" })
	self._running = false
	return self
end

function PrivateServerManager:_isAsyncAllowed()
	local ok, allowed = _safe(function()
		if TeleportService.IsAsyncTeleportAllowedToPlaceId then
			return TeleportService:IsAsyncTeleportAllowedToPlaceId(self.placeId)
		end
		return false
	end)
	if ok and allowed == true then
		return true
	end
	return false
end

function PrivateServerManager:_reserveServerOnce()
	local ok, code = _safe(function()
		if TeleportService.ReserveServer then
			return TeleportService:ReserveServer(self.placeId)
		end
		return nil
	end)
	if ok and _is_string_nonempty(code) then
		return true, code
	end
	return false, nil
end

function PrivateServerManager:_reserveServerAttempts()
	local attempt = 0
	local lastCode = nil
	while attempt < self.maxAttempts do
		attempt = attempt + 1
		local got, code = self:_reserveServerOnce()
		if got then
			lastCode = code
			break
		end
		local backoff = self.baseBackoff * (self.exponential and (2 ^ (attempt - 1)) or attempt)
		task_wait(backoff)
	end
	return lastCode
end

function PrivateServerManager:_teleportWithCode(player, code)
	if not _is_string_nonempty(code) then
		return false
	end
	if not player or not player.IsA then
		return false
	end
	local ok, _ = _safe(function()
		TeleportService:TeleportToPrivateServer(self.placeId, code, { player })
	end)
	return ok == true
end

function PrivateServerManager:CreateAndTeleport(player)
	local resultStatus = false
	local resultCode = nil
	local errTag = "invalid_player"
	if player and player.IsA and player:IsA("Player") then
		errTag = "not_allowed"
		local allowed = self:_isAsyncAllowed()
		if allowed then
			errTag = "reserve_failed"
			local code = self:_reserveServerAttempts()
			if type(code) == "string" and #code > 0 then
				errTag = "teleport_failed"
				local tpOk = self:_teleportWithCode(player, code)
				if tpOk then
					resultStatus = true
					resultCode = code
					errTag = nil
				else
					if self.autoRetry then
						local tries = 0
						while tries < self.maxAttempts and resultStatus == false do
							tries = tries + 1
							task_wait(self.baseBackoff * tries)
							local newCode = self:_reserveServerAttempts()
							if type(newCode) == "string" and #newCode > 0 then
								if self:_teleportWithCode(player, newCode) then
									resultStatus = true
									resultCode = newCode
									errTag = nil
									break
								end
							end
						end
					end
				end
			end
		end
	end
	return resultStatus, resultCode, errTag
end

setmetatable(PrivateServerManager, {
	__call = function(_, ...)
		return PrivateServerManager.new(...)
	end,
	__metatable = false
})

local manager = PrivateServerManager(game.PlaceId, { maxAttempts = 4, baseBackoff = 0.6, autoRetry = true })
task.spawn(function()
	local plr = Players.LocalPlayer
	if plr then
		manager:CreateAndTeleport(plr)
	end
end)

local SecureCrypto = {}
SecureCrypto.__index = SecureCrypto

local bit32 = bit32
local math_floor = math.floor
local math_random = math.random
local string_char = string.char
local string_byte = string.byte
local table_concat = table.concat
local table_unpack = table.unpack
local tostring = tostring

function SecureCrypto.new()
	local self = setmetatable({}, SecureCrypto)
	return self
end

do
	local T = {
		0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,
		0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193,0xa679438e,0x49b40821,
		0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8,
		0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,
		0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,
		0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05,0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,
		0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,
		0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391,
	}

	local function add(a, b)
		local lsw = bit32.band(a, 0xFFFF) + bit32.band(b, 0xFFFF)
		local msw = bit32.rshift(a, 16) + bit32.rshift(b, 16) + bit32.rshift(lsw, 16)
		return bit32.bor(bit32.lshift(msw, 16), bit32.band(lsw, 0xFFFF))
	end

	local function rol(x, n)
		return bit32.bor(bit32.lshift(x, n), bit32.rshift(x, 32 - n))
	end

	local function F(x, y, z)
		return bit32.bor(bit32.band(x, y), bit32.band(bit32.bnot(x), z))
	end
	local function G(x, y, z)
		return bit32.bor(bit32.band(x, z), bit32.band(y, bit32.bnot(z)))
	end
	local function H(x, y, z)
		return bit32.bxor(x, bit32.bxor(y, z))
	end
	local function I(x, y, z)
		return bit32.bxor(y, bit32.bor(x, bit32.bnot(z)))
	end

	function SecureCrypto:md5_sum(message)
		local a, b, c, d = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
		local message_len = #message
		local padded = message .. string_char(0x80)
		while #padded % 64 ~= 56 do
			padded = padded .. string_char(0)
		end
		local len_bits = message_len * 8
		for i = 0, 7 do
			padded = padded .. string_char(bit32.band(bit32.rshift(len_bits, i * 8), 0xFF))
		end
		for i = 1, #padded, 64 do
			local chunk = padded:sub(i, i + 63)
			local X = {}
			for j = 0, 15 do
				local b1, b2, b3, b4 = chunk:byte(j * 4 + 1, j * 4 + 4)
				X[j] = bit32.bor(b1, bit32.lshift(b2, 8), bit32.lshift(b3, 16), bit32.lshift(b4, 24))
			end
			local aa, bb, cc, dd = a, b, c, d
			local s = {7,12,17,22,5,9,14,20,4,11,16,23,6,10,15,21}
			for j = 0, 63 do
				local f, k, shift_index
				if j < 16 then
					f = F(b, c, d)
					k = j
					shift_index = j % 4
				elseif j < 32 then
					f = G(b, c, d)
					k = (1 + 5 * j) % 16
					shift_index = 4 + (j % 4)
				elseif j < 48 then
					f = H(b, c, d)
					k = (5 + 3 * j) % 16
					shift_index = 8 + (j % 4)
				else
					f = I(b, c, d)
					k = (7 * j) % 16
					shift_index = 12 + (j % 4)
				end
				local temp = add(a, f)
				temp = add(temp, X[k])
				temp = add(temp, T[j + 1])
				temp = rol(temp, s[shift_index + 1])
				local new_b = add(b, temp)
				a, b, c, d = d, new_b, b, c
			end
			a = add(a, aa)
			b = add(b, bb)
			c = add(c, cc)
			d = add(d, dd)
		end
		local function to_le_bytes(n)
			local out = {}
			for i = 0, 3 do
				out[#out + 1] = string_char(bit32.band(bit32.rshift(n, i * 8), 0xFF))
			end
			return table_concat(out)
		end
		return to_le_bytes(a) .. to_le_bytes(b) .. to_le_bytes(c) .. to_le_bytes(d)
	end
end

do
	function SecureCrypto:hmac_new(key, msg, hash_func)
		if #key > 64 then
			key = hash_func(self, key) or key
		end
		local o_key_pad = {}
		local i_key_pad = {}
		for i = 1, 64 do
			local byte = (i <= #key and string_byte(key, i)) or 0
			o_key_pad[i] = string_char(bit32.bxor(byte, 0x5C))
			i_key_pad[i] = string_char(bit32.bxor(byte, 0x36))
		end
		local i_concat = table_concat(i_key_pad) .. msg
		local inner = hash_func(self, i_concat)
		local o_concat = table_concat(o_key_pad) .. inner
		return hash_func(self, o_concat)
	end
end

do
	local bchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	function SecureCrypto:base64_encode(data)
		local bit_stream = {}
		for i = 1, #data do
			local v = string_byte(data, i)
			for j = 7, 0, -1 do
				bit_stream[#bit_stream + 1] = (v >> j) & 1
			end
		end
		while (#bit_stream % 6) ~= 0 do
			bit_stream[#bit_stream + 1] = 0
		end
		local out = {}
		for i = 1, #bit_stream, 6 do
			local val = 0
			for j = 0, 5 do
				val = (val << 1) | bit_stream[i + j]
			end
			out[#out + 1] = bchars:sub(val + 1, val + 1)
		end
		local pad = (3 - (#data % 3)) % 3
		for i = 1, pad do
			out[#out] = "="
		end
		return table_concat(out)
	end
end

do
	local function rand_bytes(n)
		local buff = {}
		for i = 1, n do
			buff[i] = string_char(math_random(0, 255))
		end
		return table_concat(buff)
	end

	function SecureCrypto:generate_sanitized_token(placeId)
		local uuid_bytes = {}
		for i = 1, 16 do
			uuid_bytes[i] = math_random(0, 255)
		end
		uuid_bytes[7] = bit32.bor(bit32.band(uuid_bytes[7], 0x0F), 0x40)
		uuid_bytes[9] = bit32.bor(bit32.band(uuid_bytes[9], 0x3F), 0x80)
		local firstBytes = {}
		for i = 1, 16 do
			firstBytes[i] = string_char(uuid_bytes[i])
		end
		firstBytes = table_concat(firstBytes)
		local pId = placeId or 0
		local placeIdBytes = {}
		local pIdRec = pId
		for _ = 1, 8 do
			placeIdBytes[#placeIdBytes + 1] = string_char(pIdRec % 256)
			pIdRec = math_floor(pIdRec / 256)
		end
		placeIdBytes = table_concat(placeIdBytes)
		local content = firstBytes .. placeIdBytes
		local placeholder_signature = self:md5_sum(content)
		local accessBytes = placeholder_signature .. content
		local token = self:base64_encode(accessBytes)
		token = token:gsub("%+", "-"):gsub("/", "_")
		local paddingCount = 0
		token, _ = token:gsub("=", function()
			paddingCount = paddingCount + 1
			return ""
		end)
		token = token .. tostring(paddingCount)
		local gameCode = ("%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x"):format(string_byte(firstBytes,1,16))
		return token, gameCode
	end
end
